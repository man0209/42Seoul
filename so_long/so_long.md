# so_long
- mlx 라이브러리를 사용해 작은 2D게임을 만들어보는 과제

# map의 크기는 어떻게 알까?
- main문에서 GNL함수를 통해 (*.ber)파일에서 한 줄 씩 읽어온다.
- 이 과제에서 허용한 문자는 0 : 땅, 1 : 벽, C : 코인, E : 출구, P : 플레이어 이 5개이다.
- .ber파일은 위의 5개의 문자로만 구성되어 있어야 하고 그 외의 문자가 있으면 아웃!
- 나의 경우 일단 GNL 함수로 파일의 끝까지 읽으면서 가로, 세로의 값을 구조체에 저장하고 준비한 이미지의 크기를 곱해서 mlx_new_window함수를 이용해 구현했다.

# 헤더파일을 수정하면 make re!!!!!

# 예외처리는 무엇을 해줬을까?
- 예외처리는 두 가지로 나눠서 해주었다.
- 첫 째, GNL로 한 줄 읽어와서 할 수 있는 부분은 바로 해주었고, 바로 읽으면서 할 수 없는 것들은
- 둘 째, GNL로 다 읽은 후 다시 한 번 처음부터 읽으면서 구조체에 이차원 배열로 만들어 모든 문자열을 복사 한 후 해주었다.
- 여기서 고민이 되었던 부분이 문자열을 담는 변수를 이차원 배열로 만드는게 좋을 지 아니면 char *에 ft_strjoin으로 그냥 다 담아서 한 줄씩 짤라서 쓰는게 좋을지 고민이 많이 되었다.
- 아직도 어떤게 더 좋은 방법인지는 모르겠지만 나는 접근하기 쉬운 2차원 배열로 만들었다.
- 물론 *.bmp 파일을 두 번 읽어야 하는 단점이 있지만 나중에 오브젝트가 벽으로 둘러쌓여있는지 확인하는 부분이 2차원배열이 더 간단하다고 생각했기 때문에 2차원 배열 선택!! 

# 벽
- 일단 벽으로 둘러쌓여져 있어야 해서 GNL로 한줄 읽을 때마다 확인을 해주었다.
- GNL로 읽은 값은 개행도 같이 들어오기 때문에 ft_strlen - 1 로 총 개수를 구하고 ft_strchr함수를 문자의 개수를 반환하도록 만들어서 사용하였다.
- 그래서 첫째줄의 경우 height = 0 이고 1의 개수와 문자의 총 개수가 같으면 다 1이므로 그렇게 처리해줬고
- height > 0 이상부터는 문자열의 [0] 번 인덱스와 [width - 1]째 인덱스가 1인지만 확인하였다.
- 마지막 줄은 한줄 씩 읽으면서 확인을 할 수 없으므로, 왜냐하면 끝 을 알수가 없으니까( 생각해보니까 GNL로 읽은 값이 EOL이면 끝이니까 할 수 있을지도??)
- GNL 로 파일을 끝까지 읽은 후 구조체의 char **변수에 문자열을 다 복사하고 난 후 마지막 줄만 따로 확인해주었다.

# 0, 1, C, E, P
- 나는 P, E 는 1개 이외는 예외로 처리해주었다.
- C 의 경우 0개면 처리.
- 그리고 GNL은 개행까지 같이 읽으므로 '\n'도 같이 처리해 주었다.
- 어차피 개행만 들어있는 맵은 벽 에러때문에 걸리니 상관 없었다.
- 벽으로 둘러쌓여있는 부분도 따로 예외처리 해주었다. 왜? 둘러쌓여있으면 못나가니까
- 함수 하나를 만들어 변수 3개를 정하고 가운데 문자열 윗 문자열 아래 문자열을 각 각 저장해놓고 가운데 문자열에서 위에 해당하는 문자, (아, 0은 제외)를 먼저 찾고 있으면 해당 문자의 인덱스를 먼저 구했다. 왜냐하면 C의 경우 한 줄에 여러 개가 있을 가능성도 있기 때문에 만약 1C0CC1 이면 총 세 번을 확인해야 한다. 그래서 문자의 개수를 확인하고 해당 개수만큼 반복하는 반복문 안에서 [1]인덱스 확인 후 해당 인덱스를 변수에 저장해서 변수 + 1 인덱스부터 확인하게끔 해서 구현하였다.

# 직사각형
- 서브젝트에서 맵은 직사각형이어야 한다고 했으므로,
- 일단 width = height 이면 정사각형이므로 패스
- 그리고 모든 줄의 width가 다 같아야하니까 GNL로 하나 하나 읽으면서 strlen으로 width랑 비교해서 처리하였다.

# 맵의 최대 크기
- 이 부분은 오늘 평가 받으면서 알게된 부분이다. 물론 fail
- 디스플레이의 최대 해상도보다 맵이 클 경우 예외 처리를 해주어야 한다.
- mlx함수에 스크린의 최대 크기를 구할 수 있는 함수를 이용해서 처리해주었다.

# 이미지 출력
- 처음에 각 문자에 맞는 이미지 출력을 어떻게 해야하나 걱정이 많았는데, 의외로 mlx 함수를 이용하니 쉽게 해결되었다.
- 따로 구조체 하나를 더 만들어서 각 각의 이미지를 가리키는 포인터를 저장하게 만들었다. 물론 mlx 함수를 이용해서
- 이미지의 포인터를 가지고있는 구조체도 동적 할당을 할 까 생각해보았는데, 굳이 할 필요가 없을 것 같았다.
- 동적 할당을 하는 이유는 보통 메모리에서 stack 보단 heap의 크기가 더 크기 때문에 동적 할당의 경우 heap의 메모리를 사용하고 들어오는 값의 크기를 모를 때(가변인자같이), 동적 할당을 사용하는 것으로 이해하고 있다. (만약 들어오는 값이 크면 stack에 다 담을 수 없기 때문에) seg오류 뜸.
- 따라서 이미지를 저장하는 구조체는 사용해야 하는 변수의 개수도 정해져있으므로 굳이 동적할당을 안해도 될 것 같았다.

# 만약 읽은 파일이 빈 파일이면?
- 이것도 혹시나 싶어서 해봤는데 펑 터져버렸다.
- GNL로 빈 파일을 읽어보니 null을 리턴하길래 GNL 리턴값이 NULL일 경우 따로 예외처리를 해주었다.

# 구조체의 이차원 배열에 문자를 복사할 때
- 아직도 포인터에 대한 개념이 많이 부족한 것 같다.
```
char *tmp = "123456"
char *a = (char *)malloc(sizeof(char) * strlen(tmp) + 1);
a = tmp;
free(tmp);
```
- 처음에 위의 코드 같이 구현하였는데, free(tmp) 후 a의 값도 이상하게 변하는 것을 보고 이거 왜 이러지? 이러면서 조금 시간을 썼었다.
- 생각을 다시 정리해보니 *a 는 주소를 가지는 포인터 변수. 따라서 a = tmp를 하게 되면 a 는 tmp의 주소를 그대로 가지고 있게 된다.
- free(tmp)를 하게 되면 tmp가 가지고 있던 값들이 사라지게 되고, a 는 tmp의 주소를 가지고 있으므로 a의 값을 역참조 해서 출력하게되면 tmp의 값을 출력하는 거랑 같은 셈이다.
- 물론 a = tmp를 하게되면 동적 할당한 주소도 어버리게 되므로 동적 할당을 한 의미도 사라지는 셈!!
- 따라서 동적할당을 한 후 ft_strcpy함수를 이용해 문자 하나 하나 a의 메모리에 복사하는 방법으로 문자열을 넣어주었다.
