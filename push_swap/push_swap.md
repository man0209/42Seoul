# push_swap?
- 들어오는 인자들을 A, B 두 개의 스택을 만들고 알고리즘을 사용해 A 스택에 오름차순으로 정렬되게 하는 과제이다. 정렬되는 과정에서 A, B 두 스택간의 이동 및 숫자들의 순서가 바뀌는 과정에서
- 각 상황에 맞는 명령어가 출력되고 이 출력되는 명령어를 최소화 시키는게 이 과제에서 요구하는 부분이다.
- 그래서 시간복잡도 보다는 명령어 최소화에 집중된 알고리즘을 사용하였다.

# 배열? 연결 리스트?
- 스택을 만드는 과정에서 배열을 사용할 지 더블 링크드 리스트를 사용할 지 고민해보았다.
- 배열로 접근하면 내가 원하는 값에 인덱스를 통해 바로 접근할 수 있는 장점이 있지만, 이 과제의 특성 상 새로운 숫자를 각 스택에 넣고 빼는 작업이 많아서 배열 보단 연결리스트가 좋아보였다.
- 그리고 지금까지 과제를 진행해오면서 더블 연결 리스트를 구현해 본적이 없었기 때문에 이번 과제에서 직접 구현해 보고 싶은 부분도 매우 컸다. ( 그 전에는 단방향 연결리스트만 구현 해보았다.)
- 물론 연결 리스트도 스택 내부의 값을 찾기 위해서 첫 노드부터 쭉 돌아야하는 단점이 있긴 하지만, 새로운 값을 추가하고 빼는 과정이 배열보단 간단하기 때문에 더블 연결리스트 선택!

# 더블 링크드 리스트 구현
- 어려웠지만 매우 재미있었다. 물론 자주 이상한 곳에 접근해서 세그폴트가 터졌다.
- 이 과제에서는 두 스택 모두 탑위치(가장 위 쪽)에 있는 값들만 다른 스택으로 이동가능하기 때문에 내가 원하는 값을 찾아 탑으로 이동시키는 과정이 필요했고, 이 과정을 반복문을 통해서 자주 반복하다보니 어느 순간 더블 링크드 리스트의 흐름에 대해 어느정도는 익숙해 진 것 같았다.
- 두 스택 모두 헤드와 테일을 먼저 구현하였고 들어오는 인자들 중 문자열이 있으면 split함수로 쪼개서 하나 하나 atoi함수로 숫자로 바꿔서 스택 a에 넣어주었다.
- 스택 하나를 동적할당 하는 과정에서 sizeof에 자료형을 안넣고 포인터를 넣는 큰? 작은? 실수를 했는데 이게 우분투에서는 안터지더라?? 클러스터에서는 바로 퍼~엉~ 요런 실수 조심해야겠다.

# 알고리즘?
- 가장 시간을 많이 쓴 부분이다. 보통 퀵 정렬, 그리디 알고리즘을 많이 사용한다고 한다.
- 이 과제에서는 정렬하는 과정에서 출력되는 명령어를 최소화하는 과제이기 때문에, 이 부분에 적합한 알고리즘 한 개를 추천받아서 사용하였다.
- 들어오는 값들의 대소 관계를 비교해서 각 값에 맞는 인덱싱 작업을 거치고(이 때 배열로 할 걸 후회 몇 번 하였음) 들어오는 인자들의 개수에 따라 chunk라는 변수 값을 정하고
- 처음에 A 스택에서 B 스택으로 넘기는 과정에서 0 ~chunk 사이의 인덱스를 먼저 넘기고 숫자가 넘어갈수록 더 큰 인덱스의 값들이 넘어가면서 결국에 B 스택에 큰 값들이 양 쪽 사이드에 위치하는 모래시계 모양으로 정렬되는 알고리즘을 사용하였다.

