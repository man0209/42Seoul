# 정렬
- 이진 탐색(Binary Search), 버블 정렬(Bubble Sort), 삽입 정렬(Insert sort), 합병 정렬(Merge sort), 퀵 정렬(Quick Sort)
- 안정 (Stable) 정렬 , 불안정(unstable) 정렬
  - 중복된 값의 순서 보장 - 안정 정렬
  - 중복된 값으 순서 보장 X -불안정 정렬
- 구현 방식에 따라서 In-place 정렬, Out-of-place 정렬
  -  원본 데이터 내에서 정렬이 이루어짐 - In-place 정렬
  -  원본이 아닌 새로운 배열로 정렬된 아웃풋 결과를 만들어내면 Out-of-place 정렬
- 정렬을 볼 때에는 정렬의 시간 복잡도, 안정정렬여부, 구현 방식 이렇게 세가지 관점에서 차이를 비교해 볼 수 있다.

# 이진 탐색(Binary Search)
-  오름차순 `정렬되어 있는` 리스트 내에서 특정 값의 인덱스를 찾는 알고리즘
-  한번의 수행 마다 절반 씩 둘로 나뉘어가며 사이즈를 줄여간다. 그래서 바이너리 탐색
-  ex) 0 ~ 20 중 9를 찾으면 0 ~ 20 중 절반인 11. 9는 11보다 작고 숫자는 이미 정렬되어 있으니 11보다 왼쪽에 있을 것. 그 다음 0 ~ 10 의 가운데 6. 이런 식으로 줄여나간다.
-  빠른 속도
  - 시간복잡도 O(lon N)
  - (N = 100) vs (log N = 6.64) // 숫자가 100개 일 경우 일반 탐색은 최대 100번, 이진 탐색은 최대 7번
- 정렬된 리스트에서만 사용 가능. 
- 1. 데이터의 중간 인덱스 값을 찾는다.
- 2. 중간 인덱스 위치를 기준으로 arr 을 절반으로 나눈다.
- 3. 나눠진 절반의 리스트에서 target 값을 찾는다.  

# 버블 정렬 (Bubble Sort)
- (i - 1) 그리고 i 인덱스 값을 비교해서 조건에 맞으면 바꾸고 아니면 그대로 둔다. 그리고 i++. 가장 끝에는 정렬이 완료된 값 배치됨. 그리고 다시 처음부터 시작.
- 인접한 두 element 의 값을 비교
- 두 값이 정렬되어 있지 않다면 위치를 교환
- 정렬이 완료된 elements를 제외하고 위의 과정을 반복
- (n-1) + (n-2) + (n-3) + ... + 2 + 1 = n(n-1) / 2
- 시간복잡도 O(N^2)
- 직관적이고 단순한 알고리즘. 쉽지만 느리기 때문에 실제로는 사용하기 어렵다.

# 삽입 정렬(Insertion Sort)
-  리스트의 앞에서부터 이미 정렬된 서브 리스트의 값들과 비교해서 자신의 위치에 값을 삽입.
-  안정 정렬
-  단순한 알고리즘
-  데이터의 이동이 많음
  - 리스트 내의 데이터가 어느 정도 정렬이 되어있는 상태일 경우 데이터의 이동이 적어짐.
  - 시간복잡도
    - 평균 -> O(n^2)
    - 최선의 경우 : 모두 정렬이 되어있는 경우 -> O(n)
    - 최악의 경우 : 역으로 정렬되어 있는 경우 -> O(n^2)  

# 합병정렬 (Merge Sort)
- 하나의 리스트를 두 개의 균등한 크기의 리스트로 분할하고 부분 리스트를 합치면서 정렬하여 전체가 정렬되게 하는 방법
- 분할 정복(Divide and Conquer) 알고리즘
  - 이렇게 하나의 문제를 동일한 유형의 작은 문제들로 분할한 다음에 작은문제에 대한 결과들을 조합해서 큰 문제를 해결하는 알고리즘
- 많이 쓰인다. 재귀함수로 구현
- 시간 복잡도 O(NlogN)

# 퀵 정렬(Quick Sort)
- 시간복잡도 O(NlogN)
- 참조 지역성(locality of reference)
  - 컴퓨터의 하드웨어의 특성때문에 더 빠른 성질을 가질 수 있다. 알고리즘 특성상 동일한 배열내에서 자리를 이동시킴. 그래서 인접한 데이터들 사이의 이동이 발생하기 때문에
  - 제일 처음 배열에 접근할 때만 실제 메모리에서 데이터를 가져오고 이후엔 캐시로 배열에 접근할 수 있기 때문에 메모리로 접근할 때보다 더 빠르게 접근 가능.
  - 캐시라는 공간은 메모리(RAM)보다 크기가 작아서 저장할 수 있는 데이터는 적지만 메인 메모리보다 훨씬 더 빠르다는 특성이 있다.
  - 그래서 컴퓨터의 프로그램은 모두 CPU에 의해서 실행되는데, 이 때 실행에 필요한 데이터들은 CPU 자체에서 들고 있는게 아니라 메모리에 들어있다.
  - 그래서 CPU는 실행에 필요한 데이터값을 찾기 위해 메모리에 접근하게 되는데, 이 때 CPU는 메인 메모리에 접근하기 전에 캐시 공간을 먼저 탐색해서 만약 캐시 공간에 필요한
  - 데이터가 있다면 캐시공간에서 가져와서 사용하지만 없다면 그 때는 메인 메모리에 접근해서 데이터를 가져온다.
  - 그렇게 한 번 메인메모리에 접근해서 데이터를 가져오게 되면 CPU는 이 데이터를 캐시에 올려놓고 다음에 동일한 데이터에 접근을 할 때에는 더 빠르게 사용할 수 있게 한다.
- 한번 결정된 pivot 값은 이후의 연산에서 제외
  - pivot 값으로 정할 인덱스는 가장 앞이어도 되고 가장 뒤여도 되고 가운데여도 된다. 그냥 내가 정하면 된다!!!!
  - pivot 값을 기준으로 원소를 재배치하게 된다.
- 추가적인 메모리 공간 사용 X
- 불안정 정렬
- Divide and conquer
