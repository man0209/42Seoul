# 인터럽트(Interrupt)
- CPU가 프로그램을 구동 중일 때, 입출력이나 예외 상황이 발생하여 처리가 필요한 경우에 CPU에 신호를 보내는 

# 시스템콜(System call)
- 프로그램이 OS 커널이 제공하는 서비스를 이용하고 싶을 때 시스템 콜을 통해 실행
- 시스템 콜이 발생하면 해당 커널 코드가 커널 모드에서 실행
- 시스템 콜의 종류
  - 프로세스/스레드 관련
  - 파일 I/O 관련
  - 소켓(네트워크) 관련
  - 장치(device) 관련
  - 프로세스 통신 관련

# 멀티스레딩
- 하나의 프로세스가 동시에 여러 작업을 실행하는데 목적

# 멀티태스킹
- 여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 cpu time을 나눠 갖는 것
- 하나의 CPU를 여러 프로세스와 여러 스레드가 나눠서 사용

# 멀티프로세싱
- 두 개 이상의 프로세서나 코어를 활용하는 시스템

# 스레드와 프로세스
- 대량주문이 들어오는 식당, 끊임없이 만들어내는 요리 하나 하나가 프로세스
- 햄버거를 만드는 작업대(프로세스)에서는 패티를 굽는 일(스레드)가, 야채를 놓는 일(스레드), 빵을 굽는 일(스레드) 등 프로세스 내에서 여러 명령을 실행하는 기본 단위.
- 즉, 하나의 프로세스에서 여러 일을 하기 위해서는 스레드 여러개가 필요
- 프로세스 내에서 프로그램 명령을 실행하는 기본 단위  

# CPU 레지스터
- CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억 장소
- 메모리 중에서 가장 빠른 속도를 가짐
- PC (Program Counter) : 다음번에 실행할 명령어의 번지를 기억하는 레지스터
- AC (Accumulator) : 연산 결과 데이터를 일시적으로 저장하는 레지스터
- IR (Instruction Register) : 가장 최근에 인출된 명령어(현재 실행 중인 명령어)가 저장되어 있는 레지스터
- SR (Status Register) : 현재 CPU의 상태를 가지고 있는 레지스터
- MAR (Memory Address Register) : PC에 저장된 명령어 주소가 사용되기 전에 일시적으로 저장되는 주소 레지스터
- MBR (Memory Buffer Register) : 기억장치에 저장될 데이터 혹은 읽혀진 데이터가 일시적으로 저장되는 버퍼 레지스터

# 멀티 코어
- 멀티프로세스와 멀티스레드는 소프트웨어적인 측면에 가깝고, 멀티 코어는 하드웨어적인 측면에 더 가깝다.
- 멀티코어와 관련된 키워드는 동시성과 병렬처리
- 동시성(Cuncurrency)
  - 하나의 코어에서 하나 이상의 프로세스(혹은 쓰레드)가 번갈아가면서 진행되지만 동시에 진행되는 것처럼 보이는 것.
  - ![image](https://user-images.githubusercontent.com/69157076/174308345-b9ba5365-8f00-4ad6-bcb3-ceaf6613cd44.png)
- 병렬처리(Parallelism)
  - 둘 이상의 코어에서 동시에 하나 이상의 프로세스(혹은 스레드)가 한꺼번에 진행되는 것.
  - 다수의 프로세서로 여러 가지 일을 각 코어에서 진행하는 것.
  - ![image](https://user-images.githubusercontent.com/69157076/174308378-08857841-bcec-47f1-b54c-f7e334f300cd.png)


# fork
- fork() 시스템 콜에 의해 새 프로세스 생성 가능.
- fork 함수에 의해 생성된 자식 프로세스는 부모 프로세스의 메모리를 그대로 복사하여 가지게 된다. 
- `fork 함수 호출 이후 코드부터 각자의 메모리를 사용하여 실행한다. `
- 두개의 프로세스(부모, 자식)는 fork() 시스템 콜 이후의 지시들을 계속 수행한다.
- 차이점은
  -  fork()후 리턴값이 0이면 자식프로세스이고, 0이 아닌 OS커널이 부여한 pid 를 리턴하면 부모 프로세스이다.
- fork() 시스템 콜 후
  - 부모는 계속 해서 실행 되거나(계속 실행 될 경우 부모 프로세스의 코드가 자식 프로세스보다 먼저 실행 된다) 또는
  - 자식 프로세스가 실행되는 동안 wait() 시스템 콜을 사용해 기다릴 수 있다. (이러면 자식프로세스의 코드가 부모 프로세스보다 먼저 실행)
  - wait() 시스템 콜을 사용하면 부모 프로세스는 ready queue에서 wait queue로 이동하고 자식 프로세스의 종료를 기다린다.
- zombie process
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 부모 일을 계속 하는 경우 좀비프로세스라 한다.
- orphan process 
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 바로 종료가 되면 부모 없는 자식 프로세스가 생성이 되고 이 부모 없는 자식 프로세스를 orphan(고아) 프로세스라 한다.

# 프로세서(Processor)
- 하드웨어적인 측면에서 "컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛"
- 이는 중앙처리장치(Central Processing Unit)를 뜻하며 폰노이만 아키텍쳐에 의해 만들어졌다면 적어도 하나 이상의 ALU(Arithmetic Logic Unit)와 처리 레지스터(Register)를 내장하고 있어야 한다.
- 프로그램이 실행되는 과정
  - 사용자가 단축 아이콘 혹은 명령행에서 프로그램을 실행한다.
  - 파일로 저장되어 있던 프로그램은 메모리(램)에 로더(Loader)에 의해 적재(load)되고 처음으로 실행해야 할 기계어 코드가 저장된 메모리의 주소를 CPU의 명령주소(IP : Instruction Pointer) 레지스터에 저장한다.
  - 프로세서(CPU)는 IP 레지스터가 가리키는 메모리의 주소에서 (처음으로) 실행할 명령어를 인출(메모리에서 CPU로 가져오는) 하여 명령 레지스터(IR : Instruction Register)에 저장한다.
  - IR에 저장된 명령을 실행하고 IP에 다음번에 실행할 명령어가 있는 주소를 저장한다.
  - 3 ~ 4를 프로그램의 끝까지 반복한다. 

# 프로세스
- 실행중인 프로그램
- 프로세스는 OS(operating system)의 작업의 단위(unit of work)
- OS의 가장 기본적인 일 - 프로세스 관리
- 프로세스는 실행되기 위해 자원(리소스)이 필요 (CPU time, memory, files, and I/O devices)
- 프로세스는 최소 1개의 메인 스레드를 갖고 있다.

# 프로세스의 memory layout
- Text section : the executable code
- Data section : 전역 변수
- Heap section : 동적 할당
- Stack section : 호출된 함수, 함수의 파라미터, 지역변수, return addresses
- 보통 stack 보다 headp 메모리가 더 크다.
- ![image](https://user-images.githubusercontent.com/69157076/173566241-03e05d71-f31d-4468-be40-5e10eec15fae.png)

# 프로세스의 상태(state)
- New : the process is being created (생성된 상태)
- Running : Instructions are being executed. (프로세스의 명령어를 CPU에 로드해서 실행시킨 상태)
- Waiting : the process is waiting for some event to occur. (1번 프로세스가 CPU에서 일하고 있을 때 2번 프로세스는 waiting  상태) 
  - such as an I/O completion or reception of a signal
- Ready : the process is waiting to be assigned to a processor. (어떤 일이 끝났길 기다리고 있다가 그 일이 끝났다는 시그널이 오면 바로 들어가는게 아니라 ready 상태로 준비)
- Terminated : the process has finished execution. (종료한 상태)
- ![image](https://user-images.githubusercontent.com/69157076/173567772-45d19628-d2d0-4119-ae8a-82ce1ed33903.png)

# 프로세스를 어떻게 관리할건데? PCB(Process Control Block) or TCB(Task Control Block)
- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 프로세스의 상태 정보를 저장하는 구조체이다.
- 프로세스 상태 관리와 문맥교환(Context Switching)을 위해 필요하다.
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.
- Process state(프로세스 상태)
  - new / running/ waiting ...
  - CPU는 프로세스를 빠른 속도로 교체하면서 여러 프로세스를 실행하게 되는데, 이 때 각각의 프로세스의 상태를 의미
- Program counter
  -  프로세스가 다음에 실행할 명령어의 주소
  -  예를 들어 청소부라는 프로세스에서 현재 하고 있는 일이 설거지라면 다음 해야할 일(프로그램 카운터)는 분리수거가 됩니다.(물론 분리수거를 하는 명령어가 들어있는 주소값)
- CPU registers
  - 프로세스가 사용중인 레지스터를 의미
  - accumulator, index register, stack pointer, general purpose registers 등이 있다.
  - stack pointer는 코드의 함수가 실행될 때 스택 프레임의 최상단 주소를 가리키는 레지스터.
  - PC 와 SP 이 두 가지는 프로세스가 컨텍스트 스위칭을 하는 등의 중요한 역할을 하도록 도와준다.
- CPU-scheduling information
  - CPU를 주거나 릴리즈 하기 위해서 필요한 scheduling 정보들
- Memory-management information
  -  메모리 관련 정보들 (동적 할당 등등)
- Accounting information
  -  CPU 사용 시간, 실제 사용된 시간
- I/O status information
  -  프로세스에 할당된 I/O 장치 리스트들을 의미
- ![image](https://user-images.githubusercontent.com/69157076/173570164-7d1e625d-4bc3-4efd-a106-78afe5dcf55f.png)

# time sharing
- time sharing 목적은 프로세스 간에 CPU core를 자주 스위치해서 사용자 입장에서는 각 각의 프로그램이 동시에 실행되는 것처럼 보이게 하는 것이다. CPU가 아주 빠르기 때문에 가능
- time sharing을 하기 위해서는 CPU를 scheduling 해줘야 하는데 이것을 scheduling Queues 라 한다.
- CPU는 하나이기 때문에 프로세스가 새로 만들어지면 ready queue에 들어가게 되고 ready queue에서 순차적으로 CPU가 사용가능하면 들어가 실행된다. 이 과정에서 실행되고 다시 ready queue로 돌아가는 경우도 있고, I/O request 나, 인터럽트에 의해서 waiting queue에 들어가는 경우도 있다. 이 때는 waiting queue 가 끝나면 바로 running queue(cpu)로 가는게 아니라 ready queue로 이동 후 대기.
- ![image](https://user-images.githubusercontent.com/69157076/173577317-75964ade-965a-4c54-9741-4de2ec42876b.png)

# Context Switch
- 예를 들어, CPU에 급한 프로세스가 처리해달라고 긴급 요청이 왔을 때 기존에 작업하던 프로세스의 상태를 PCB에 저장되고 , CPU는 context switching으로 급한 프로세스의 PCB를 통해 해당 프로세스를 실행시키고 해당 작업이 끝나면, 다시 전의 프로세스의 PCB를 통해 하던 일을 이어서 하게 된다.
- CPU는 레지스터에 있는 정보를 보고 처리작업을 수행한다. 따라서 A프로세스를 돌리다 B프로세스를 돌려야 하면 지금 CPU의 레지스터에 저장되어 있는 A프로세스의 정보를 어딘가에 저장을 해야한다. 이 정보를 A프로세스의 PCB에 저장을 한다. 즉 CPU에서 수행되던 레지스터 값들이 저장이 되는 것이다. 내가 수행하던 프로세스가 어디까지 수행됐는지(프로그램 카운터), stack pointer의 위치가 어디인지, 그 외 register들의 집합 정보들을 잠시 저장한다. 그리고 B프로세스의 PCB의 정보들을 불러와 B프로세스를 실행시킨다.
- 이렇게 수행중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것을 Context Switching(문맥 교환)이라고 한다.
- 즉, CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정을 말한다.
- 그럼 문맥교환은 언제 발생할까?
  - 인터럽트가 발생(급한 프로세스 먼저 처리해줘야 하니까)
  - 실행 중인 프로세스가 CPU사용을 허가받은 시간(Time Quantum)을 모두 소모했을 때
  - I/O 입출력을 위해 대기해야 하는 경우(키보드로부터 입력받는 동안 비싼 CPU를 놀리면 안되니까 I/O 작업이 끝날 때까지 다른 프로세스 돌림) 
- ![image](https://user-images.githubusercontent.com/69157076/173585227-98897e8a-e150-4256-ac8b-441983948163.png)

# 스레드(thread)
- 경량화된 프로세스 (한 프로세스 안의 스레드들은 고유의 레지스터와 스택을 제외한 나머지 부분을 프로세스와 공유)
- 그렇기 때문에 스레드간의 컨텍스트 스위칭은 프로세스간의 컨텍스트 스위칭보다 훨씬 가볍다. 프로세스들은 서로 리소스를 공유하지 않기 때문에 바꿀 때마다 전부 다 읽어야 하지만 스레드는 공유하는 자원만 제외하고 읽으면 되기 때문에
- CPU 활용의 기본 단위 // a basic unit of CPU utilization
- 프로세스 내에서 프로그램 명령을 실행하는 기본 단위 
- thread ID, program counter, register set(집합), stack 으로 구성되어 있다.
- ![image](https://user-images.githubusercontent.com/69157076/173779865-55458ed9-ce16-4200-bbc9-f4d5563e83c6.png)
- 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, open files 등의 운영체제 자원 공유

# 단일 스레드(Single Thread)
- 프로그램 내 제어 스레드 1개
- 1개의 레지스터, 1개의 스택
- 장점
  - 자원을 공용화 하지 않으므로 공용 자원 접근 통제 불필요
  - Context Switch 작업 불필요
- 단점
  - 다수개의 CPU 활용이 불가
- ![image](https://user-images.githubusercontent.com/69157076/173837357-a51a2324-ca75-4d16-9c7d-615f9814a8d8.png)

# 멀티 스레드(Multi Thread)
- 멀티 스레드와 멀티 프로세스를 한 어플리케이션에 대한 처리방식이라고 생각하자.
- 예를 들어서 여러 사용자가 로그인을 요청하는 상황이 있다고 하면 한 프로세스는 매번 하나의 로그인만 처리할 수 있기 때문에 동시에 처리할 수 없다 그래서 부모 프로세스가 fork()를 해서 자식 프로세스를 여러개 만든 후 일을 처리하도록 한다. 이 때 자식 프로세스는 부모 프로세스와는 별개의 메모리 영역을 가지게 된다.
- 반면 스레드는 한 프로세스 내에서 구분지어진 실행 단위, 만약에 프로세스가 다수의 스레드로 구분되어 있지 않다면 단일 스레드 하나로 프로세스가 실행된다. 이 떄 실행 단위는 프로세스 그 자체가 된다.
- 프로세스 내에서 분리해서 여러 스레드로 나뉘어서 실행단위가 나뉘어지면 그게 멀티스레드. 멀티스레드는 한 스레드에 문제가 생기면 전체 프로세스에 영향이 간다.
- 프로그램을 다수의 실행 단위로 나누어 실행
- 각각의 스레드가 고유의 레지스터와 스택으로 표현
- 하나의 응용 프로그램에서 여러개의 비슷한 일을 해야 하는 경우, 예를 들어 웹서버는 클라이언트에게 동영상, 소리, 메시지 등 여러 요청을 받는데,
- 만약 스레드가 싱글이면 오래 걸린다. 만약 프로세스를 여러 개 만들어서 하면 되지 않을까?  하지만 프로세스 생성 작업 자체가 오래 걸리는 작업이고 리소스도 많이 쓰이기 때문에
- 굳이 오버헤드를 감소하면서까지 프로세스를 많이 만들 필요가 없다.
- 장점
  - 대응적 측면 : 일부가 차단되거나 장시간 작업 수행시에도 계속해서 실행 가능
    - 싱글 스레드의 경우 하나 있는 스레드가 종료되면 끝이지만, 멀티 스레드의 경우 하나가 종료되도 나머지가 돌아가고 있고, 종료된 스레드도 다시 시작될 수도 있다 
  - 자원 공유성(Resource Sharing) : 프로세스의 자원과 상태를 공유. 효율적인 운영
  - 경제성(Economy) : 자신이 속한 프로세스의 자원을 공유하기 때문에, 스레드를 만들고 context switch를 진행하는 것이 더 경제적
  - 확장성(scalability) : 다수개의 코어에서 병렬로 프로세스 실행

# User thread
- 우리가 #include <thread.h> 혹은 import를 통해 스레드를 이용하는 것을 의미
- 스레드 API 라이브러리는 스레드를 제어할 자료구조와 알고리즘을 담고 있다. 라이브러리가 유저영역 메모리 안에 존재하므로 커널 모드로 전환되지 않아도 스레드를 제어할 수 있다. 커널영역에는 스레드 제어 블록을 포함한 제어 알고리즘이 존재하지 않으므로 유저 영역에서의 스레드에 간섭할 수 없다. 그러므로 커널 영역의 프로세스가 블록되어도 스레드는 죽지 않고 계속 돌아간다.
- 유저 스레다그 CPU에서 실행되려면 OS 스레드와 반드시 연결되어야 한다.(보통 one-to-one 으로 많이 쓴다고 한다)
- 장점
  - 커널모드 전환이 필요없어 오버헤드가 없고 응용 프로그램에 맞는 스케줄링 구성이 가능하고 어떤 운영체제에도 호환이 된다.
- 단점
  - 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다.(무슨 스레드가 먼저 동작할 지 모른다)
  - 프로세스에 속한 스레드 중 I/O 작업등에 의해 하나라도 블록이 걸린다면 전체 스레드가 블록된다.

# Kernel thread
- 커널 내에 있는 스레드를 의미하고 아래의 3가지 방법으로 나뉜다. 
- ![image](https://user-images.githubusercontent.com/69157076/174309991-81fd6c68-6e73-4873-adca-a2d6e66d3f4b.png)
- many-to-one model은 요즘 잘 안쓰인다고 한다. 최근 운영체제들은 one-to-one model을 사용, 자바나 파이썬도 one-to-one model 사용한다고 한다.
- OS 커널 레벨에서 생성되고 관리되는 스레드
- 장점
  - 프로세스의 스레드들을 몇 몇 프로세서에 한꺼번에 디스패치 할 수 있기 때문에 멀티프로세서(CPU) 환경에서 매우 빠르게 동작한다.
    - 디스패치 : (CPU가 사용가능한 상태가 될 때 ready queue에 있는 프로세스를 Running 상태로 바꿔주는(State Transition) 것) 
    - 디스패처(dispatcher) 가 이 일을 수행한다.
  - 다른 스레드가 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업을 진행할 수 있다. 
  - 커널이 각 스레드를 개별적으로 관리할 수 있다.
  - 커널이 직접 스레드를 제공해 주기 때문에 안전성과 다양한 기능이 제공된다.
- 단점
  - OS 스레드의 컨텍스트 스위칭은 커널이 개입해서 진행한다.
  - 즉, 컨텍스트 스위칭이 일어날 떄마다 유저모드에서 커널모드로 전환되고 여러 커널코드가 CPU에서 실행되기 때문에 CPU가 사용되고 끝나면 커널모드에서 유저모드로 다시 전환되어야 하기 떄문에 비용이 발생한다. ( 시간적인 비용, CPU 리소스 비용)

# 프로세스 동기화
- 데이터 정합성 이슈의 발생
  - 동시에 공유 데이터에 접근한다면 데이터 불일치가 발생할 수 있다.
  - 데이터 일관성을 유지하려면 협력 프로세스간의 순차적인 실행을 보장하는 매커니즘이 필요

# 교착상태(Deadlock)
- 한 시스템에 다음 네 가지 조건 동시성립 시 교착상태가 발생할 수 있음
  - 상호배제(Mutual exclusion)
    - 두 프로세스는 동시에 같은 자원에 접근할 수 없음
    - 다른 프로세스가 그 자원을 요청하면, 요청프로세스는 자원이 해제될 때까지 대기한 뒤 사용 가능
    - 공유 가능한 리스소 설정(ex.읽기 전용 파일)
  - 점유하며 대기(Hold-and-wait)
    - 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 함.
    - 프로세스가 작업을 수행하기 전에 필요한 자원을 모두 요청하고 획득해야함(최대 자원 할당)
    - 단점 : 리소스 활용도 낮음 / 기아 발생 가능성
  - 비선점(No preemption)
    - 자원들을 선점할 수 없어야 함
    - 자원이 강제적으로 해제될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후에만 해제됨
    - 선점의 경우 다른 프로세스들이 진행되고 있는 중간에 껴서 새치기 느낌?
    - 이미 할당된 자원에 선점권이 없어야함.
    - 기존 사용중이던 프로세스가 작업 내용을 잃을 수 있음.
  - 순환 대기(Circular wait)
    - 자원들이 cyclic하게 점유한 자원들을 대기해야 함 
- deadlock 은 위 넷 중 하나만 끊어도 막을 수 있다.

# 동기화(Synchronization)
- 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지하는 것
- 두 개의 프로세스나 스레드가 동시에 메모리에 접근하면 race condition(경쟁 조건)이 발생함.
- 떄문에 이들이 메모리에 접근할때의 순서를 잘 지켜줘야하는데, 이를 동기화라고 한다.
- 예를 들어 예금 계좌 잔액을 나타내는 total 변수가 존재하고, 현재 잔고가 1000원이 있다고 가정할 때, 동시에 두 개의 쓰레드에서 total 변수를 참조해서 100원을 인출하는 상황을 생각해보자
- 첫 번째 스레드에서 현재 잔고가 1000원이므로 100원을 빼서 900원의 값을 total에 할당하는 중이고,
- 두 번째 스레드도 현재 잔고가 1000원인 시점에 참조해서 100원을 빼서 900원의 값을 total에 할당한다면, 실제로는 200원을 빼서 total 변수의 최종 값이 800원이 되어야 하지만 900원인 문제 상황이 발생할 수 있다.
- 이 `크리티컬 섹션`을 `상호 배제(Mutual Exclusion)` 하는 방식으로 접근을 동기화해야 한다.
- pthread에서 상호 배제를 위해 제공하는 락(lock) 매커니즘으로 뮤텍스(mutex)가 존재한다.

# 경쟁 조건(Race Condition)
- 여러 프로세스/스레드가 동시에 같은 데이터를 조작할 때 타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황
- 여러 프로세스/스레드가 동시에 공유 자원에 접근하는 상태
- 멀티스레드 프로그래밍을 할 경우에는 특히 동기화 문제를 꼭 고려해주어야 한다.

# 임계 영역(Critical section)
- 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역
- 스레드가 실행 중 다른 스레드가 끼어들지 말아야 하는 영역

# Critical-Section 해결책이 되기 위한 조건
- mutual exclusion(상호 배제)
  - 한번에 하나의 프로세스/스레드만 임계 영역에서 실행 가능 
  - 어떻게 mutual exclusion을 보장할까? -> Lock을 사용하자!!
- progress(진행)
  - 만약에 임계 영역이 비어있고 어떤 스레드나 프로세스가 이 임계 영역에 들어오기 원한다면 그 중의 하나는 임계 영역에서 실행되게끔 해야한다. 즉 계속 진행되어야 한다.
- bounded waiting(한정된 대기)
  - 어떤 프로세스나 스레드가 무한정 임계 영역에 들어오지 못하고 대기하고 있으면 안된다는 조건.
위 3개의 조건을 모두 만족해야 크리티컬 섹션의 문제를 해결책이 될 수 있다.

# 스핀락(spinlock)
- 락을 취득하기 위해 계속해서 시도(반복문)하는 방식
- 끊임없이 계속해서 while 루프의 조건문을 확인하기 위해 CPU cycle을 낭비한다는 점이 단점.
- 다른 프로세스나 스레드가 더 유용하게 사용할 수도 있었을 CPU cycle이기 때문에 다른 프로세스나 스레드에게 피해를 주는 것이라고 볼 수 있다.

# 뮤텍스 락(Mutex Lock)
```
mutex lock;
...critical section
mutex unlock;
```
- 뮤텍스 락을 취득하길 시도. 락을 취득하는데 성공한 스레드는 critical section에서 자기 할 일을 한 뒤에 critical section을 빠져나가면서 락을 반환.
- 만약 이 스레드가 critical section에서 동작하는 동안 다른 스레드가 뮤텍스 락을 취득하려고 한다면, 취득에 실패하고 락을 취득 할 때 자신을 깨워달라고 요청한 뒤 대기 상태로 전환.
- 이런 형태로 뮤텍스는 critical section의 mutual exclusion을 보장.
- 락을 취득할 수 있을 때까지 계속 확인하는 것이 아니라, 락이 준비되면 나를 깨워달라고 요청하고 대기(waiting) 상태(state)로 전환하는 것.
- 프로세스는 critical section에 진입하기 전 반드시 락을 획득해야함. critical section 사용 종료 시 잠금 해제
- 잠금 사용가능 여부를 나타내는 Boolean 변수 사용
- 그러나, busywaiting이 존재함(spinlock)

# 뮤텍스가 스핀락보다 항상 좋은 걸까?
- 만약 멀티 코어 환경이고, critical section에서의 작업이 컨텍스트 스위칭에 걸리는 시간보다 더 빨리 끝난다면 스핀락이 뮤텍스보다 더 이점이 있다.
- 뮤텍스에서는 락을 취득하지 못한 스레드가 큐에 들어가게 되고 나중에 깨워줘야 하는데 이 과정에서 컨텍스트 스위칭이 발생한다.
- 컨텍스트 스위칭은 cpu를 꽤 잡아먹는 작업. 만약 이렇게 컨텍스트 스위칭을 하는 것보다 critical section에서의 작업이 더 빨리 끝난다면, 스핀락 방식이 일단 시간적으로는 이점이 있다.
- 그럼 왜 멀티 코어 환경이라는 조건이 붙을까? 싱글코어 환경에서는 스핀락이 전혀 이점이 없기 때문이다. 싱글 코어에서 락을 취득하기 위해 스레드가 스핀락 방식으로 기다리고 있다면, 누군가가 락을 해제를 해야 하는데, 그러려면 반드시 그 누군가로 컨텍스트 스위칭이 일어나야 하고, 그 누군가가 락을 해제한 뒤에는 기다리고 있는 스레드로 또다시 컨텍스트 스위칭이 일어나야 하기 때문이다.
- 하지만 멀티 코어 환경에서 락을 취득한 스레드와 락을 기다리는 스레드가 서로 다른 코어에서 실행 중이라면, 이 경우에는 컨텍스트 스위칭이 발생하지 않는다. 그래서 이런 조건일 때, critical section에서의 작업 시간이 컨텍스트 스위칭에 걸리는 시간보다 짧다면 이때는 스핀락이 이점이 있다는 것이다.

# Atomic operation
- 실행 중간에 간섭받거나 중단되지 않는다.
- 같은 메모리 영역에 대해 동시에 실행되지 않는다.
