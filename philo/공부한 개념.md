# 인터럽트(Interrupt)
- CPU가 프로그램을 구동 중일 때, 입출력이나 예외 상황이 발생하여 처리가 필요한 경우에 CPU에 신호를 보내는 것

# fork
- fork() 시스템 콜에 의해 새 프로세스 생성 가능.
- fork 함수에 의해 생성된 자식 프로세스는 부모 프로세스의 메모리를 그대로 복사하여 가지게 된다. 
- `fork 함수 호출 이후 코드부터 각자의 메모리를 사용하여 실행한다. `
- 두개의 프로세스(부모, 자식)는 fork() 시스템 콜 이후의 지시들을 계속 수행한다.
- 차이점은
  -  fork()후 리턴값이 0이면 자식프로세스이고, 0이 아닌 OS커널이 부여한 pid 를 리턴하면 부모 프로세스이다.
- fork() 시스템 콜 후
  - 부모는 계속 해서 실행 되거나(계속 실행 될 경우 부모 프로세스의 코드가 자식 프로세스보다 먼저 실행 된다) 또는
  - 자식 프로세스가 실행되는 동안 wait() 시스템 콜을 사용해 기다릴 수 있다. (이러면 자식프로세스의 코드가 부모 프로세스보다 먼저 실행)
  - wait() 시스템 콜을 사용하면 부모 프로세스는 ready queue에서 wait queue로 이동하고 자식 프로세스의 종료를 기다린다.
- zombie process
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 부모 일을 계속 하는 경우 좀비프로세스라 한다.
- orphan process 
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 바로 종료가 되면 부모 없는 자식 프로세스가 생성이 되고 이 부모 없는 자식 프로세스를 orphan(고아) 프로세스라 한다.

# 프로세스
- 실행중인 프로그램
- 프로세스는 OS(operating system)의 작업의 단위(unit of work)
- OS의 가장 기본적인 일 - 프로세스 관리
- 프로세스는 실행되기 위해 자원(리소스)이 필요 (CPU time, memory, files, and I/O devices)

# 프로세스의 memory layout
- Text section : the executable code
- Data section : 전역 변수
- Heap section : 동적 할당
- Stack section : 호출된 함수, 함수의 파라미터, 지역변수, return addresses
- 보통 stack 보다 headp 메모리가 더 크다.
- ![image](https://user-images.githubusercontent.com/69157076/173566241-03e05d71-f31d-4468-be40-5e10eec15fae.png)

# 프로세스의 상태(state)
- New : the process is being created (생성된 상태)
- Running : Instructions are being executed. (프로세스의 명령어를 CPU에 로드해서 실행시킨 상태)
- Waiting : the process is waiting for some event to occur. (1번 프로세스가 CPU에서 일하고 있을 때 2번 프로세스는 waiting  상태) 
  - such as an I/O completion or reception of a signal
- Ready : the process is waiting to be assigned to a processor. (어떤 일이 끝났길 기다리고 있다가 그 일이 끝났다는 시그널이 오면 바로 들어가는게 아니라 ready 상태로 준비)
- Terminated : the process has finished execution. (종료한 상태)
- ![image](https://user-images.githubusercontent.com/69157076/173567772-45d19628-d2d0-4119-ae8a-82ce1ed33903.png)

# 프로세스를 어떻게 관리할건데? PCB(Process Control Block) or TCB(Task Control Block)
- PCB는 특정 프로세스와 관련된 많은 정보를 가지고 있다.
  - Process state(프로세스 상태)
    - new / running/ waiting ...
  - Program counter
    -  IR(Instruction Register)가 특정 메모리에 있는 명령어를 fetch하는데, program counter의 레지스터가 가리키고 있는 메모리를 fetch한다.
    -  프로세스가 다음에 실행할 명령어의 주소
  - CPU registers
    - IR, DR(data register) : Program counter 도 일종의 CPU registers. Program counter, CPU registers 이 둘을 합쳐 context라 부른다.
    - 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터, 상태 코드 정보 포함
  - CPU-scheduling information
    - CPU를 주거나 릴리즈 하기 위해서 필요한 scheduling 정보들
  - Memory-management information
    -  메모리 관련 정보들 (동적 할당 등등)
  - Accounting information
    -  어떤 유저가 만들었는지
  - I/O status information
    -  어떤 파일을 오픈했고 그런 정보들
 - 위의 정보들을 각각의 프로세스당 한개씩 구조체로 만들어 저장.
 - ![image](https://user-images.githubusercontent.com/69157076/173570164-7d1e625d-4bc3-4efd-a106-78afe5dcf55f.png)
 - 프로세스는 single thread of execution인데, 이 말은 실타래가 풀리는 것처럼 single thread(실), 한 개의 실이 쭉 풀리는 것처럼 일(실행)을 한다는 말이다.
 - 그렇게 쭉 일을 하다가 CPU가 다른 프로세스를 실행시키면 실 푸는 걸 멈추고(일을 멈추고) 그 정보를 PCB에 저장해 놓고 CPU가 다시 이 프로세스를 실행시키면 저장해 놓은 위치로 이동해 쭉 이어서 일을 한다. 
 - 그러나 single thread 는 한번에 한가지 일밖에 하지 못하기 때문에 요즘 OS는 이 프로세스 컨셉을 확장해 프로세스가 multiple threads of execution을 할 수 있도록 한다.

# time sharing
- time sharing 목적은 프로세스 간에 CPU core를 자주 스위치해서 사용자 입장에서는 각 각의 프로그램이 동시에 실행되는 것처럼 보이게 하는 것이다. CPU가 아주 빠르기 때문에 가능
- time sharing을 하기 위해서는 CPU를 scheduling 해줘야 하는데 이것을 scheduling Queues 라 한다.
- CPU는 하나이기 때문에 프로세스가 새로 만들어지면 ready queue에 들어가게 되고 ready queue에서 순차적으로 CPU가 사용가능하면 들어가 실행된다. 이 과정에서 실행되고 다시 ready queue로 돌아가는 경우도 있고, I/O request 나, 인터럽트에 의해서 waiting queue에 들어가는 경우도 있다. 이 때는 waiting queue 가 끝나면 바로 running queue(cpu)로 가는게 아니라 ready queue로 이동 후 대기.
- ![image](https://user-images.githubusercontent.com/69157076/173577317-75964ade-965a-4c54-9741-4de2ec42876b.png)

# Context Switch
- 프로세스의 context 는 PCB에 들어있다.
- Context 는 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함.
- 인터럽트가 발생했을 때 시스템은 작동중인 프로세스의 최근 context를 저장한다.
- 그리고 후에 다시 돌아왔을 때 저장해놓은 context를 복원(restore)한다.
- context switch란 CPU core를 다른 프로세스에게 넘겨주는 건데,
- 이 때, 현재 프로세스의 state(context)를 저장하고
- 새로 들어오는 프로세스의 state를 restore 한다. 
- ![image](https://user-images.githubusercontent.com/69157076/173585227-98897e8a-e150-4256-ac8b-441983948163.png)

# 스레드(thread)
- CPU 활용의 기본 단위 // a basic unit of CPU utilization
- 프로세스 내에서 프로그램 명령을 실행하는 기본 단위 
- thread ID, program counter, register set(집합), stack 으로 구성되어 있다.
- ![image](https://user-images.githubusercontent.com/69157076/173779865-55458ed9-ce16-4200-bbc9-f4d5563e83c6.png)
- 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, open files 등의 운영체제 자원 공유

# 단일 스레드(Single Thread)
- 프로그램 내 제어 스레드 1개
- 1개의 레지스터, 1개의 스택
- 장점
  - 자원을 공용화 하지 않으므로 공용 자원 접근 통제 불필요
  - Context Switch 작업 불필요
- 단점
  - 다수개의 CPU 활용이 불가
- ![image](https://user-images.githubusercontent.com/69157076/173837357-a51a2324-ca75-4d16-9c7d-615f9814a8d8.png)

# 멀티 스레드(Multi Thread)
- 프로그램을 다수의 실행 단위로 나누어 실행
- 각각의 스레드가 고유의 레지스터와 스택으로 표현
- 하나의 응용 프로그램에서 여러개의 비슷한 일을 해야 하는 경우, 예를 들어 웹서버는 클라이언트에게 동영상, 소리, 메시지 등 여러 요청을 받는데,
- 만약 스레드가 싱글이면 오래 걸린다. 만약 프로세스를 여러 개 만들어서 하면 되지 않을까?  하지만 프로세스 생성 작업 자체가 오래 걸리는 작업이고 리소스도 많이 쓰이기 때문에
- 굳이 오버헤드를 감소하면서까지 프로세스를 많이 만들 필요가 없다.
- 장점
  - 대응적 측면 : 일부가 차단되거나 장시간 작업 수행시에도 계속해서 실행 가능
    - 싱글 스레드의 경우 하나 있는 스레드가 종료되면 끝이지만, 멀티 스레드의 경우 하나가 종료되도 나머지가 돌아가고 있고, 종료된 스레드도 다시 시작될 수도 있다 
  - 자원 공유성(Resource Sharing) : 프로세스의 자원과 상태를 공유. 효율적인 운영
  - 경제성(Economy) : 자신이 속한 프로세스의 자원을 공유하기 때문에, 스레드를 만들고 context switch를 진행하는 것이 더 경제적
  - 확장성(scalability) : 다수개의 코어에서 병렬로 프로세스 실행

# 프로세스 동기화
- 데이터 정합성 이슈의 발생
  - 동시에 공유 데이터에 접근한다면 데이터 불일치가 발생할 수 있다.
  - 데이터 일관성을 유지하려면 협력 프로세스간의 순차적인 실행을 보장하는 매커니즘이 필요

# Critical-Section(임계구역)
- 각 프로세스에는 임계 구역이라고 하는 코드 세그먼트가 존재
  - 프로세스가 액세스하고, 업데이트하는 데이터, 적어도 하나의 다른 프로세스와 공유됨
- 하나의 프로세스가 임계 구역에서 실행 중일 때, 다른 프로세스들은 해당 임계 구역에 접근할 수 없음
- 일반적으로 프로세스는 진입구역 / 퇴출구역, 나머지구역으로 구성
- critical section 문제 해결을 위한 요구조건
  - Mutual Exclusion(상호배제)
    - 프로세스 Pi가 임계구역에서 실행될 때, 다른 어떤 프로세스도 임계 구역에 접근할 수 없음.
  - Progress(진행)
    - critical section에서 실행중인 프로세스가 없고, 임계구역에 들어가고자 하는 프로세스가 존재한다면, 나머지 구역에서 실행중이지 않은 프로세스들만 다음 임계구역에 진입할 프로세스를 결정하는데 참여 할 수 있음. 이 선택은 무한정 연기할 수 없음
  - Bounded Watiting(제한이 있는 대기시간)
    - 프로세스가 자신의 critical section에 진입하려는 요청을 한 후부터, 그 요청이 허용될 때까지 다른 프로세스들이 자신들의 critical section에 진입하도록 허용되는 횟수에 한계가 있어야 함. 

# 뮤텍스 락(Mutex Lock)
- 뮤텍스 락을 이용하여 critical section을 보호, 경쟁 방지
- 프로세스는 critical section에 진입하기 전 반드시 락을 획득해야함. critical section 사용 종료 시 잠금 해제
- 잠금 사용가능 여부를 나타내는 Boolean 변수 사용
- 그러나, busywaiting이 존재함(spinlock)

# 교착상태(Deadlock)
- 한 시스템에 다음 네 가지 조건 동시성립 시 교착상태가 발생할 수 있음
  - 상호배제(Mutual exclusion)
    - 두 프로세스는 동시에 같은 자원에 접근할 수 없음
    - 다른 프로세스가 그 자원을 요청하면, 요청프로세스는 자원이 해제될 때까지 대기한 뒤 사용 가능
    - 공유 가능한 리스소 설정(ex.읽기 전용 파일)
  - 점유하며 대기(Hold-and-wait)
    - 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 추가로 얻기 위해 반드시 대기해야 함.
    - 프로세스가 작업을 수행하기 전에 필요한 자원을 모두 요청하고 획득해야함(최대 자원 할당)
    - 단점 : 리소스 활용도 낮음 / 기아 발생 가능성
  - 비선점(No preemption)
    - 자원들을 선점할 수 없어야 함
    - 자원이 강제적으로 해제될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후에만 해제됨
    - 선점의 경우 다른 프로세스들이 진행되고 있는 중간에 껴서 새치기 느낌?
    - 이미 할당된 자원에 선점권이 없어야함.
    - 기존 사용중이던 프로세스가 작업 내용을 잃을 수 있음.
  - 순환 대기(Circular wait)
    - 자원들이 cyclic하게 점유한 자원들을 대기해야 함 
- deadlock 은 위 넷 중 하나만 끊어도 막을 수 있다.
- 


# 스레드 동기화
- 스레드 생성의 경우 프로세스 생성과 달리 한 프로세스 내에서 생성된 여러 스레드들은 메모리 주소 공간을 공유한다
- 한 프로세스 내에서 생성된 여러 프로세스들이 동시에 특정 전역 변수를 참조하는 경우를 생각해보자
- 예를 들어 예금 계좌 잔액을 나타내는 total 변수가 존재하고, 현재 잔고가 1000원이 있다고 가정할 때, 동시에 두 개의 쓰레드에서 total 변수를 참조해서 100원을 인출하는 상황을 생각해보자
- 첫 번째 스레드에서 현재 잔고가 1000원이므로 100원을 빼서 900원의 값을 total에 할당하는 중이고,
- 두 번째 스레드도 현재 잔고가 1000원인 시점에 참조해서 100원을 빼서 900원의 값을 total에 할당한다면, 실제로는 200원을 빼서 total 변수의 최종 값이 800원이 되어야 하지만 900원인 문제 상황이 발생할 수 있다.
- 위와 같이 동시에 공유 자원에 동시에 접근하는 상태를 `경쟁 상태`라 하고, 동시에 참조되는 공유 자원을 참조하는 영역, 즉 스레드가 실행 중 다른 스레드가 끼어들지 말아야 하는 영역을 `크리티컬 섹션`이라고 한다.
- 이 `크리티컬 섹션`을 `상호 배제(Mutual Exclusion)` 하는 방식으로 접근을 동기화해야 한다.
- pthread에서 상호 배제를 위해 제공하는 락(lock) 매커니즘으로 뮤텍스(mutex)가 존재한다.
