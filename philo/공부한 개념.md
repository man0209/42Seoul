
# fork
- fork() 시스템 콜에 의해 새 프로세스 생성 가능.
- fork 함수에 의해 생성된 자식 프로세스는 부모 프로세스의 메모리를 그대로 복사하여 가지게 된다. 
- `fork 함수 호출 이후 코드부터 각자의 메모리를 사용하여 실행한다. `
- 두개의 프로세스(부모, 자식)는 fork() 시스템 콜 이후의 지시들을 계속 수행한다.
- 차이점은
  -  fork()후 리턴값이 0이면 자식프로세스이고, 0이 아닌 OS커널이 부여한 pid 를 리턴하면 부모 프로세스이다.
- fork() 시스템 콜 후
  - 부모는 계속 해서 실행 되거나(계속 실행 될 경우 부모 프로세스의 코드가 자식 프로세스보다 먼저 실행 된다) 또는
  - 자식 프로세스가 실행되는 동안 wait() 시스템 콜을 사용해 기다릴 수 있다. (이러면 자식프로세스의 코드가 부모 프로세스보다 먼저 실행)
  - wait() 시스템 콜을 사용하면 부모 프로세스는 ready queue에서 wait queue로 이동하고 자식 프로세스의 종료를 기다린다.
- zombie process
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 부모 일을 계속 하는 경우 좀비프로세스라 한다.
- orphan process 
  - 부모 프로세스가 자식 프로세스를 생성 후 wait를 안하고 바로 종료가 되면 부모 없는 자식 프로세스가 생성이 되고 이 부모 없는 자식 프로세스를 orphan(고아) 프로세스라 한다.



# 프로세스
- 실행중인 프로그램
- 프로세스는 OS(operating system)의 작업의 단위(unit of work)
- OS의 가장 기본적인 일 - 프로세스 관리
- 프로세스는 실행되기 위해 자원(리소스)이 필요 (CPU time, memory, files, and I/O devices)

# 프로세스의 memory layout
- Text section : the executable code
- Data section : 전역 변수
- Heap section : 동적 할당
- Stack section : 호출된 함수, 함수의 파라미터, 지역변수, return addresses
- 보통 stack 보다 headp 메모리가 더 크다.
- ![image](https://user-images.githubusercontent.com/69157076/173566241-03e05d71-f31d-4468-be40-5e10eec15fae.png)

# 프로세스의 상태(state)
- New : the process is being created (생성된 상태)
- Running : Instructions are being executed. (프로세스의 명령어를 CPU에 로드해서 실행시킨 상태)
- Waiting : the process is waiting for some event to occur. (1번 프로세스가 CPU에서 일하고 있을 때 2번 프로세스는 waiting  상태) 
  - such as an I/O completion or reception of a signal
- Ready : the process is waiting to be assigned to a processor. (어떤 일이 끝났길 기다리고 있다가 그 일이 끝났다는 시그널이 오면 바로 들어가는게 아니라 ready 상태로 준비)
- Terminated : the process has finished execution. (종료한 상태)
- ![image](https://user-images.githubusercontent.com/69157076/173567772-45d19628-d2d0-4119-ae8a-82ce1ed33903.png)

# 프로세스를 어떻게 관리할건데? PCB(Process Control Block) or TCB(Task Control Block)
- PCB는 특정 프로세스와 관련된 많은 정보를 가지고 있다.
  - Process state(프로세스 상태)
    - new / running/ waiting ...
  - Program counter
    -  IR(Instruction Register)가 특정 메모리에 있는 명령어를 fetch하는데, program counter의 레지스터가 가리키고 있는 메모리를 fetch한다.
  - CPU registers
    - IR, DR(data register) : Program counter 도 일종의 CPU registers. Program counter, CPU registers 이 둘을 합쳐 context라 부른다.
  - CPU-scheduling information
    - CPU를 주거나 릴리즈 하기 위해서 필요한 scheduling 정보들
  - Memory-management information
    -  메모리 관련 정보들 (동적 할당 등등)
  - Accounting information
    -  어떤 유저가 만들었는지
  - I/O status information
    -  어떤 파일을 오픈했고 그런 정보들
 - 위의 정보들을 각각의 프로세스당 한개씩 구조체로 만들어 저장.
 - ![image](https://user-images.githubusercontent.com/69157076/173570164-7d1e625d-4bc3-4efd-a106-78afe5dcf55f.png)
 - 프로세스는 single thread of execution인데, 이 말은 실타래가 풀리는 것처럼 single thread(실), 한 개의 실이 쭉 풀리는 것처럼 일(실행)을 한다는 말이다.
 - 그렇게 쭉 일을 하다가 CPU가 다른 프로세스를 실행시키면 실 푸는 걸 멈추고(일을 멈추고) 그 정보를 PCB에 저장해 놓고 CPU가 다시 이 프로세스를 실행시키면 저장해 놓은 위치로 이동해 쭉 이어서 일을 한다. 
 - 그러나 single thread 는 한번에 한가지 일밖에 하지 못하기 때문에 요즘 OS는 이 프로세스 컨셉을 확장해 프로세스가 multiple threads of execution을 할 수 있도록 한다.

# time sharing
- time sharing 목적은 프로세스 간에 CPU core를 자주 스위치해서 사용자 입장에서는 각 각의 프로그램이 동시에 실행되는 것처럼 보이게 하는 것이다. CPU가 아주 빠르기 때문에 가능
- time sharing을 하기 위해서는 CPU를 scheduling 해줘야 하는데 이것을 scheduling Queues 라 한다.
- CPU는 하나이기 때문에 프로세스가 새로 만들어지면 ready queue에 들어가게 되고 ready queue에서 순차적으로 CPU가 사용가능하면 들어가 실행된다. 이 과정에서 실행되고 다시 ready queue로 돌아가는 경우도 있고, I/O request 나, 인터럽트에 의해서 waiting queue에 들어가는 경우도 있다. 이 때는 waiting queue 가 끝나면 바로 running queue(cpu)로 가는게 아니라 ready queue로 이동 후 대기.
- ![image](https://user-images.githubusercontent.com/69157076/173577317-75964ade-965a-4c54-9741-4de2ec42876b.png)

# Context Switch
- 프로세스의 context 는 PCB에 들어있다.
- 인터럽트가 발생했을 때 시스템은 작동중인 프로세스의 최근 context를 저장한다.
- 그리고 후에 다시 돌아왔을 때 저장해놓은 context를 복원(restore)한다.
- context switch란 CPU core를 다른 프로세스에게 넘겨주는 건데,
- 이 때, 현재 프로세스의 state(context)를 저장하고
- 새로 들어오는 프로세스의 state를 restore 한다. 
- ![image](https://user-images.githubusercontent.com/69157076/173585227-98897e8a-e150-4256-ac8b-441983948163.png)






# 스레드 동기화
- 스레드 생성의 경우 프로세스 생성과 달리 한 프로세스 내에서 생성된 여러 스레드들은 메모리 주소 공간을 공유한다
- 한 프로세스 내에서 생성된 여러 프로세스들이 동시에 특정 전역 변수를 참조하는 경우를 생각해보자
- 예를 들어 예금 계좌 잔액을 나타내는 total 변수가 존재하고, 현재 잔고가 1000원이 있다고 가정할 때, 동시에 두 개의 쓰레드에서 total 변수를 참조해서 100원을 인출하는 상황을 생각해보자
- 첫 번째 스레드에서 현재 잔고가 1000원이므로 100원을 빼서 900원의 값을 total에 할당하는 중이고,
- 두 번째 스레드도 현재 잔고가 1000원인 시점에 참조해서 100원을 빼서 900원의 값을 total에 할당한다면, 실제로는 200원을 빼서 total 변수의 최종 값이 800원이 되어야 하지만 900원인 문제 상황이 발생할 수 있다.
- 위와 같이 동시에 공유 자원에 동시에 접근하는 상태를 `경쟁 상태`라 하고, 동시에 참조되는 공유 자원을 참조하는 영역, 즉 스레드가 실행 중 다른 스레드가 끼어들지 말아야 하는 영역을 `크리티컬 섹션`이라고 한다.
- 이 `크리티컬 섹션`을 `상호 배제(Mutual Exclusion)` 하는 방식으로 접근을 동기화해야 한다.
- pthread에서 상호 배제를 위해 제공하는 락(lock) 매커니즘으로 뮤텍스(mutex)가 존재한다.
