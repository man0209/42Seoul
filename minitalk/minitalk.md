# Minitalk
- Minitalk 과제는 IPC(Inter-Process Communication), 즉 프로세스 간 통신을 구현하는 과제이다. 서버와 클라이언트 각 각 실행파일을 만들고 클라이언트에서 서버로 string을 보내면 서버에서 받은 string을 출력하는 과제이다.
- 지금까지 C 과제를 해오면서 위에서 아래로 순차적으로 실행되는 코드만 보다가 시그널이 들어오면 시그널 핸들러를 찾아 동작하는 게 생각보다 적응되지 않았었다.
- 아래 예제에서 코드가 while 문 안의 pause상태에서 시그널이 들어오면 그 위에 있는 sigaction함수가 실행되어 해당 시그널 핸들러가 동작.
```
sigaction(SIGUSR1, &signal_handler, NULL);

while (1)
{
    pause( );
}
```

- 처음에는 signal 함수만 사용해서 구현했었지만, 동료 카뎃으로부터 signal 함수보단 sigaction 함수가 더 많은 기능을 가지고 있고 더 많이 사용된다는 말을 듣고 처음부터 다시 구현하기 시작했다.

# 과제 하면서 어려웠던 점.
- sigaction 구조체를 이해하기가 정말 어려웠다. 구글링을 통해 함수의 구조와, 각 각의 역할에 대해서 찾아보고 직접 테스트를 해보며 진행했다.
- 아래와 같은 구조를 가지고 있는 함수인데, sig에 해당하는 시그널이 들어오면 두번 째 인자인 act 구조체를 핸들러로서 동작하게 하는 시그널 제어 함수이다. 세번 째 인자는 이전의 동작 방식을 저장하는 데, 이번 과제에서는 사용하지 않아 NULL로 지정했다.

```
int sigaction(int sig, const struct sigaction *restrict act, struct sigaction *restrict oldact)
```
- 두번 째 인자인 struct sigaction 은 아래의 구조인데, signal 함수와 다른 점이 sa_mask를 통해 시그널 블록을 설정할 수 있는데, 여기서 시그널 블록이란 해당 시그널을 처리하는 핸들러가 동작을 완료하기 전에는 다른 시그널 처리가 안된다는 의미이다. 이번 과제에서는 이 시그널 집합 처리 함수로 sigemptyset, sigaddset 이 두 함수를 사용 할 수 있게 했다. sigemptyset 은 이 시그널 집합을 모두 비우는 것이고 (0) sigaddset은 내가 원하는 시그널을 넣을 수 있는 함수이다(1). 만약 sigemptyset으로 가져갈 경우 시그널 핸들러가 작동될 때 다른 시그널이 발생하면 바로 현재 시그널에 끼어들어버리게 된다. 즉, 완벽한 핸들러의 수행종료를 보장할 수 없단 의미.
- 그리고 sa_flags 에 SA_SIGINFO 를 설정하면 sa_handler가 아니라 sa_sigaction 이 시그널을 처리하는 함수로 동작한다.
- struct sigaction
- ![image](https://user-images.githubusercontent.com/69157076/162975618-ac45d072-c99c-4181-8a58-45241ecb1a7f.png)


- siginfo_t
- ![image](https://user-images.githubusercontent.com/69157076/162977114-3bfb4ead-a1c6-4198-afb2-b60140195aa7.png)
- 위 개념을 익힌 후, sigaction 함수의 핸들러, sa_mask, sa_flags를 설정하는 함수를 구현하였지만, 클라이언트에서 신호가 왔을 때 내가 원하는 핸들러가 동작하게 끔 하는 부분에서 문제가 생겼다.
- 분명 sigaction 함수 설정을 초기화 하고 시그널 핸들러 설정도 마쳤지만, 해당 시그널이 들어왔을 때 시그널 핸들러가 동작하지 않아서 해당 시그널의 디폴트 값으로 인해 프로세스가 종료되는 문제가 발생했다. 동료 카뎃에게 도움을 요청한 결과, 내가 짠 코드의 구조 상 sigaction 함수가 해당 시그널을 받지 못하는 구조였다. 이 문제도 동료 카뎃 덕분에 해결하였는데, 함수를 만들고 그 안에 sigaction 함수와 pause( )함수를 같이 넣어서 시그널이 들어올 때 까지 해당 함수 내에서 멈춰있다가 시그널이 들어오면 그 함수 안에 있는 시그널핸들러가 동작하게끔 구현해서 해결하였다.
- 서로 다른 여러 클라이언트에서 한 서버로 문자열을 보낼 경우 서버에서 여러 클라이언트가 보낸 문자가 섞여서 출력되지 않도록 하기 위해 서버에서 지금 데이터를 받고 있는 클라이언트의 pid를 저장해서 서버가 클라이언트로부터 문자를 받을 때 내가 저장한 pid 와 맞는지 비교해서 맞으면 문자를 받아서 출력, 아니면 다른 시그널을 보내 해당 클라이언트가 종료되게끔 구현하였는데 이 과정에서 서버는 종료되지 않고 계속 켜져있어야 하고, 첫번 째 클라이언트가 문자를 다 보내고 난 후 다른 클라이언트로 문자를 보내면 문제 없이 출력이 되는 부분에서 문제가 발생하였다.
- 첫번 째 문제는 첫번 째 클라이언트 문자가 출력 된 후 두번 째 클라이언트로 문자를 보냈을 때 서버가 첫번 째 pid를 계속 가지고 있어서 두번 째 클라이언트의 pid 와 달라 해당 클라이언트를 종료시켜버리는 문제였다. 이 문제는 첫번 째 클라이언트 문자 출력 후, 서버가 새로운 클라이언트의 pid를 다시 저장하는 방식으로 구현해서 해결하였다.
- 두번 째 문제는 서버가 새로운 클라이언트의 pid를 저장하는 시기였다. 첫번째 클라이언트가 문자를 다 보내기 전까지는 서버가 첫번째 클라이언트의 pid를 계속 가지고 있어야 한다. 그럼 첫번째 클라이언트가 문자를 다 보낸 후 서버가 pid를 바꿔야 하는데 어떻게 해야 할까? 이 부분은 클라이언트가 문자를 다 보낸 후 널문자 '\0'을 마지막으로 서버로 보내고 서버에서 플래그를 따로 만들어 클라이언트에서 널문자가 왔을 경우 플래그의 값을 바꿔 문자를 받는 함수를 종료시키고 다시 클라이언트의 pid를 저장하는 함수가 시작되게끔 구현해서 해결하였다.

# 끝
- 이번 과제를 하면서 머리로만 생각하는 멍청한 짓은 절대로 하면 안되겠구나 라고 생각을 많이 하였다. 시그널 보내고 시그널 받고 이 시그널 핸들러로 처리하고 다시 시그널 보내고 받고...... 손으로 노트에 시그널의 순서를 그려가면서 하니 훠~얼씬 편했다. 역시 인간은 도구를 써야하나보다. 정말 많은 벽을 느꼈는데 그 때 마다 가야하는 방향을 알려준 동료 카뎃한테 이 모든 영광을 돌리고 싶다. 아 이번 과제 진짜 힘들었다.

